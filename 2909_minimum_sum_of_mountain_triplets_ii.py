def minimumSum(nums: list) -> int:
    '''
    :param nums: дан список целых чисел
    :return: нужно вернуть минимальную сумму трех чисел из которых можно собрать "гору". Горой считается такая
    последовательность, в которой первое число будет меньше второго, а второе бодет больше третьего. При этом
    эти числа могут находится на расстоянии друг от друга. Главное чтоб последовательность индексов первого,
    второго и третьего была строго возврастающей. У этой задачи был аналог версии easy, которая решалась
    вложенными циклами. Но в этой версии - lvl medium - такой факус с решением в лоб уже не пройдет - упремся
    в TL. Поэтому решил поступить следующим образом: заранее вычисляем минимум числа справа и числа слева.
    Минимум слева при движении вперед легко обновляется - сравниваем два числа и сохраняем минимальное.
    Минимум справа немного сложнее. Я сравниваю текущее число с минимумом справа. Если они равны: обновляю
    минимум через встроенную функцию. Иначе - двигаюсь дальше)
    '''
    if len(set(nums)) < 2:
        return -1

    minimalSum = 10 ** 10
    minLeft = nums[0]
    minRight = min(nums[2:])
    for i in range(1, len(nums) - 1):
        minLeft = min(minLeft, nums[i - 1])

        if nums[i] == minRight:
            minRight = min(nums[i + 1:])

        if minLeft < nums[i] > minRight:
            curSum = minLeft + nums[i] + minRight
            minimalSum = min(minimalSum, curSum)

    return minimalSum if minimalSum < 10 ** 10 else -1


# nums = [5, 4, 8, 7, 10, 2]
# print(minimumSum(nums))
