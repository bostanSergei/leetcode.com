def numberOfLines(widths, s):
    '''
    :param widths: список из 26 элементов. Каждый элемент - это число символов, которое занимает в строке
    каждая буква английского алфавита. То есть если widths начинается следующим образом [2, 34, 5, 8...
    то для того чтобы напечатать букву A - потреуется 2 символа, букву B - 34 символа, букву С - 5 и т.д.
    :param s: та самая строка, которую нам нужно "напечатать". На нашей странице максимальная вместимость
    символов - 100 единиц. То есть если А = 10, то на одной строке я могу напечатать только 10 букв А
    :return: нужно вернуть список, в котором первым значением будет количество строк, которые я занял
    при написании текста, а вторым - количество символов, занятых в последней строке

    Задача - костыль на костыле) Во первых, если мы заняли в строке допустим 95 символов, а следующая буква
    занимает больше 5ти символов, то мы должны перенесети строку на новую и начать набор символа с новой
    строки. Во вторых нужно проверять значения, полученные на выходе. Если мы уместились ровно в 4 строки,
    именно 4 и нужно возвращать, при этом второе значение в итоговом списке будет 100. Короче, костыли наше всё)
    По скорости показали не плохой результат. Другие варианты решения, кончено же есть, но изначально
    мной была выбрана не совсем верная тактика подсчета, поэтому переписывать не решился, ведь у самурая
    есть только путь, поэтому как-то так)
    '''
    wordsDict = dict(zip('abcdefghijklmnopqrstuvwxyz', widths))
    result = 0
    for i in s:
        if (result + wordsDict[i]) // 100 > result // 100 and (result + wordsDict[i]) % 100 != 0:
            result = result + (100 - result % 100)
        result += wordsDict[i]

    resList = [result // 100 + 1, result % 100]
    if resList[1] == 0:
        return [resList[0] - 1, 100]
    return resList


# widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]
# s = "abcdefghijklmnopqrstuvwxyz"
# print(numberOfLines(widths, s))