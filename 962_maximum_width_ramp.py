def maxWidthRamp(nums: list) -> int:
    '''
    :param nums: список чисел
    :return: вернуть максимально возможное расстояние между двумя элементами списка, так чтобы выполнялись
    следующие условия: индекс первого числа (i) должен быть меньше индекса второго числа (j) и nums[i] должен
    быть меньше или равен nums[j]
    lvl - medium. Как и многие задачи среднего уровня сложности, при вложенном цикле мы упираемся в time limit.
    Требуется более оптимальное решение. В данном случае я создаю новый список в котором каждый элемент это еще
    один список, состоящий из двух элементов - самого значения и индекса этого элемента. Это потребуется нам
    для того, чтобы на следующем этапе отсортировать получившийся список по стартовым значениям.
    После сортировки мы точно будем знать, что каждый следующий элемент нашего списка будет точно больше или равен
    предыдущему. Останется только поработать с индесами, что и будет реализовано в цикле за один проход.
    Зная, что стандартная сортировка выполняется примерно за log(n) - итоговая сложность алгоритма будет n*log(n).
    '''
    width, lenList = 0, len(nums)
    indexNums = [[nums[i], i] for i in range(lenList)]

    indexNums.sort(key=lambda x: x[0])

    minIndex = indexNums[0][1]
    for i in range(1, lenList):
        width = max(indexNums[i][1] - minIndex, width)
        minIndex = min(minIndex, indexNums[i][1])

    return width


nums = [9, 8, 1, 0, 1, 9, 4, 0, 4, 1]
print(maxWidthRamp(nums))
