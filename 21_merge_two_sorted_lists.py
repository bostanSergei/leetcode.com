class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


def mergeTwoLists(list1: ListNode, list2: ListNode):
    '''
    :param list1: дано два односвязных массива
    :param list2: задача перебрать эти спсики и вернуть односвязный отсортированный массив
    В этой задаче мы создаем новую вершину односвязного списка и ставим указатель на эту вершину.
    Далее руководствуемся следующим принципом: пока односвязные списки не пусты, будем сравнивать значения элементов
    этих списков и в соответствии с этими зависимостями к нашей вершине один за другим будем "подключать" новые
    элементы. Когда дойдем до ситуации, в которой в одном из массивов закончатся элементы, мы свяжем два последних элемента
    и вернем ссылку на head. Задача lvl - easy, но пока для меня все так же достаточно сложно даются подобного рода
    задачи. В последнее время я стараюсь сфокусироваться на бинарных деревьях, односвязных и двусвязных массивах,
    но пока чет прям трудно. Надеюсь в ближайшей перспективе начну щелкать подобного рода задачи как орехи)
    '''
    head = ListNode()
    curr = head
    while list1 and list2:
        if list1.val < list2.val:
            curr.next = list1
            list1 = list1.next
        else:
            curr.next = list2
            list2 = list2.next
        curr = curr.next

    curr.next = list1 or list2
    return head.next
