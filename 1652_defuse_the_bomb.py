def decrypt(code, k):
    '''
    :param code: список целых чисел
    :param k: ключ списка, относительно которого будем вносить в список изменения
    :return: готовый список)
    В общем, если k == 0, вернуть список нулей. Если k > 0, наша задача поставить на i-ое место сумму К-чисел,
    которое идут после i-ого числа (считаем массив чисел цикличным). Если k < 0, делаем тоже самое, только в
    обратную сторону. Предположим есть массив [1, 2, 3, 4] для нулевого индекса с парметром k == 2 мы будем
    складывать 2 и 3 и ставить полученную пятерку на место единицы. А для третьего индекса (для числа 4) будем
    складывать 1 и 2 (не забываем про цикличность массива). С k < 0 аналогчино, но в другую сторону.
    lvl - easy. Мой runtime - на 96% лучше чем предыдущие решения. В условиях сказано, что k не может быть
    больше длины нашего списка, поэтому для работы я сделал "удвоенную" копию изначального списка, из которой по
    индексам и брал необходимые мне элементы. А с k < 0 решил, что самым простым способом будет просто перевернуть
    списки перед стартом и после финиша) Таким образом у получился одинаковый алгорит получения элементов)
    '''
    resList, flag = [0] * len(code), False
    if k == 0:
        return resList
    copyList = code[:] * 2
    if k < 0:
        copyList.reverse()
        flag = True
        k = abs(k)
    for i in range(len(code)):
        code[i] = sum(copyList[(i + 1):(i + 1 + k)])

    if flag:
        code.reverse()
        return code
    return code


# code = [5,7,1,4]
# k = 3
# code = [2,4,9,3]
# k = -2
# print(decrypt(code, k))