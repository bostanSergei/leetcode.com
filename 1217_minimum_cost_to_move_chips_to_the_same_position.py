def minCostToMoveChips(position):
    '''
    lvl - easy, НО я в этой задаче накрутил чет уж по перебору. Ищу какие-то сложные решения на пустом месте
    :param position: список чисел. Каждое число - это порядковый номер, на котором находтся текущая фишка
    :return: вернуть минимальное количество очков, необходимое для перестрановки всех фишек на одну позицию
    Представим что есть список [2, 2, 2, 2] - это значит что у нас все четыре финки стоят на второй позиции
    Их вообще никуда перемещать не нужно. Или [2, 2, 2, 1] - одну из фишек с первой позиции нужно переставить
    на втроую позицию, так как перестановка трех фишек со второй позиции занимает больше сил и времени.
    Очки мы прибавляем в том случае, если разница позиций нечетная. За перестановку одной фишки - одно очко
    То есть если бы у нас был список [2, 2, 2, 4], то фишка с четвертой позиции переместилась бы на вторую
    за 0 очков, так как 4 - 2 = 2, а двойка - четное число.
    Решение - ниже, но я чет усложнил, хотя time - не самы плохой. Оптимизировать, наверное, не буду
    '''
    newDict, minIndex, maxIndex = {}, min(position), max(position)
    for num in position:
        if num not in newDict:
            newDict[num] = 0
        newDict[num] += 1
    newList = list(newDict.keys())
    score = 10 ** 9
    for i in newList:
        newScore = 0
        for key, val in newDict.items():
            if key != i:
                if abs(key - i) % 2 == 0:
                    continue
                else:
                    newScore += (1 * val)
        if newScore < score:
            score = newScore
    return score


# position = [1,1000000000]
# # position = [2,2,2,3,3]
# print(minCostToMoveChips(position))