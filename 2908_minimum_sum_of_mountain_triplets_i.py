def minimumSum(nums: list) -> int:
    '''
    :param nums: список неупорядоченных чисел
    :return: вернуть минимальную сумму трех чисел, если они подходят по следующему условию: индексы упорядочены,
    но первое число меньше второго, а второе больше третьего. Правда сама задача у автора почему-то называется
    min sum in mountain triplets, что лично мне как бы намекало на то, что три элемента должны быть соседними
    элементами, а по факту это оказалось не так. Изначально решал задачу через один цикл, поэтому в последствии
    решил пойти по протаренной дорожке, добавив парочку дополнительных циклов.
    Можно было один раз пробежать по списку и вычислять минимум слева и минимум справа от рассматриваемого числа.
    Но это уже совсем другая история. lvl - easy
    '''
    minSum = 150
    for i in range(len(nums) - 2):
        for j in range(i + 1, len(nums) - 1):
            for k in range(j + 1, len(nums)):
                if nums[i] < nums[j] > nums[k]:
                    curr = sum([nums[i], nums[j], nums[k]])
                    if curr < minSum:
                        minSum = curr

    return -1 if minSum == 150 else minSum


# nums = [8, 6, 1, 5, 3]
# print(minimumSum(nums))
