class LRUCache:
    '''
    Задача: реализовать класс, работающий по типу Least Recently Used (LRU) cache.
    Честно говоря понятия не имею что это такое, но не суть.
    При инициализации у нас есть размер нашего объекта. Хранить значений больше, чем указанный размер мы не можем.
    Каждый раз когда мы добавляем значение, мы должны проверить, хватает ли нам "памяти". Если нет, то самый
    "редко-используемый" объект нам нужно удалить из нашего кэша. Если мы хотим получить значение по ключу,
    то задача вернуть -1 если такого ключа не существует или значение, если ключ есть. При этом возврат существуещего
    значения - это + к "касанию", то есть объект становится на строчку "выше" по приоритету на вылет. Возможно объяснил
    не очень понятно, но надеюсь суть ясна. Я решил использовать для решения этой задачи обычный словарь и пользоваться
    фактом того, что словарь, по факту - упорядоченная структура данных. То есть каждый раз, когда я "дергал" объект
    из словаря, я дополнительным шагом удалял и снова добавлял в словарь. Таким образом он появлялся в "самом конце"
    моего словаря. А если требовалось добавить новый объект, но свободный объем словаря не позволял мне этого сделать,
    я удалял значение по самому первому ключу и снова закидывал в словарь.
    lvl задачи - medium
    '''
    def __init__(self, capacity: int):
        self.dataDict, self.len_data = {}, capacity

    def get(self, key: int) -> int:
        if key not in self.dataDict:
            return -1

        value = self.dataDict[key]
        del self.dataDict[key]
        self.dataDict[key] = value
        return value

    def put(self, key: int, value: int) -> None:
        if key in self.dataDict:
            del self.dataDict[key]
            self.dataDict[key] = value

        elif key not in self.dataDict:
            if len(self.dataDict) < self.len_data:
                self.dataDict[key] = value

            else:
                keys = list(self.dataDict.keys())
                firstKey = keys[0]
                del self.dataDict[firstKey]
                self.dataDict[key] = value
