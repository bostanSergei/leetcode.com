def oddCells(m, n, indices):
    '''Необходимо изначально инициализировать матрицу с размерами m * n и заполнить её нулями.
    Суть задания - перебрать значения матрицы indeces: list(list(int)) в которой есть [Ri, Ci],
    каждый из которых отвечает за строку и столбец нашей нулевой матрицы и каждый раз мы должны
    увеличивать значения наших стобцов и строк на еденицу. К примеру, если у нас есть изначальная
    матрица [[0, 0], [0, 0]] и мы встречаем в indeces элемент [1, 0] это значит что необходимо
    увеличить сначала первую строку нашей матрицы на единицу и она будет выглядеть так: [[0, 0], [1, 1]]
    а потом увеличить нулевой столбец. Матрица станет: [[1, 0], [2, 1]]. В конечном итоге нам нужно будет
    вернуть количество нечетных элементов нашей матрицы. То есть при входных данных m = 2, n = 2 и
    indeces = [[1, 0]] наш ответ будет 2, так как в итоговой матрице только два нечнетных числа.

    На этапе написания первых строчек кода приходит в голову две идеи: либо перебирать значения
    indeces и с каждым значением перебирать матрицу, либо один раз перебрать indeces, сформировать
    словарь, по которму на следующем этапе одним единственным проходом изменить нулевую матрицу
    По сути изменять матрицу то и не надо. Но я это делаю и после проверяю условие четности, увеличивая
    финальную переменную result
    UPD: решение в топ по времени выполнения)'''
    matrix = [[0] * n] * m
    lineDict = {i: 0 for i in range(m)}
    columnDict = {i: 0 for i in range(n)}
    for i in indices:
        lineDict[i[0]] += 1
        columnDict[i[1]] += 1
    result = 0
    for i in range(len(matrix)):
        for j in range(len(matrix[i])):
            matrix[i][j] = lineDict[i] + columnDict[j]
            if matrix[i][j] % 2 == 1:
                result += 1

    return result



# for test
# m = 2
# n = 3
# indices = [[0,1],[1,1]]
# m = 2
# n = 2
# indices = [[1, 1],[0, 0]]
# print(oddCells(m, n, indices))